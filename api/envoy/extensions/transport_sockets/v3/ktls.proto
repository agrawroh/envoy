syntax = "proto3";

package envoy.extensions.transport_sockets.v3;

import "envoy/config/core/v3/base.proto";
import "google/protobuf/any.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.v3";
option java_outer_classname = "KTlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/v3;transport_socketsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: kTLS transport socket configuration]

// Configuration for kTLS transport socket. This wraps another transport socket (like tls) and
// offloads the TLS processing to the kernel after the handshake is complete.
message KTls {
  // The underlying transport socket configuration.
  config.core.v3.TransportSocket transport_socket = 1;

  // Options for configuring kTLS.
  KTlsOptions options = 2;
}

// Options specific to the kernel TLS implementation.
message KTlsOptions {
  // Enable kTLS offload. If not specified, the implementation will detect if kTLS
  // is supported by the kernel and enable it if possible.
  bool enable_ktls = 1;

  // Enable TLS_TX_ZEROCOPY_RO optimization for transmit path when supported.
  // This allows zero-copy operation on transmit when the NIC supports TLS offload.
  bool enable_tx_zerocopy = 2;

  // Enable TLS_RX_EXPECT_NO_PAD optimization for receive path when supported.
  // This can improve performance with TLS 1.3 but should only be used when the
  // remote is trusted not to pad records.
  bool enable_rx_no_pad = 3;
} 