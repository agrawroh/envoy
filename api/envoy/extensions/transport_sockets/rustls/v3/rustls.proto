syntax = "proto3";

package envoy.extensions.transport_sockets.rustls.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.rustls.v3";
option java_outer_classname = "RustlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/rustls/v3;rustlsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Rustls TLS transport socket with kTLS support]
// [#extension: envoy.transport_sockets.rustls]

// Rustls-based TLS transport socket configuration with optional kernel TLS (kTLS) offload support.
// This transport socket uses the rustls library instead of BoringSSL, enabling features like
// kTLS which offloads TLS encryption/decryption to the Linux kernel for improved performance.

// Rustls TLS configuration for upstream connections.
message RustlsUpstreamTlsContext {
  // Common TLS context settings.
  CommonTlsContext common_tls_context = 1 [(validate.rules).message = {required: true}];

  // Optional Server Name Indication (SNI) to send in the TLS handshake.
  // If not specified, SNI will be derived from the cluster name or endpoint hostname.
  string sni = 2;

  // If true, allows connecting to servers without certificate validation.
  // WARNING: This is insecure and should only be used for testing.
  bool allow_insecure_connections = 3;

  // Maximum TLS protocol version to negotiate.
  // If not specified, uses TLS 1.3 by default.
  TlsVersion max_protocol_version = 4;

  // Minimum TLS protocol version to accept.
  // If not specified, uses TLS 1.2 by default.
  TlsVersion min_protocol_version = 5;

  // Enable kernel TLS (kTLS) offload for improved performance.
  // When enabled, TLS encryption and decryption are performed by the Linux kernel
  // instead of in userspace, reducing CPU usage and enabling zero-copy operations.
  // Requires Linux kernel 4.13+ with kTLS support enabled.
  google.protobuf.BoolValue enable_ktls = 6;

  // If true, only enable kTLS for TX (transmit/encryption) direction.
  // RX (receive/decryption) will continue using userspace TLS.
  // This can be useful for troubleshooting or working around kernel issues.
  // Only takes effect if enable_ktls is also true. Defaults to false.
  bool ktls_tx_only = 7;
}

// Rustls TLS configuration for downstream connections.
message RustlsDownstreamTlsContext {
  // Common TLS context settings.
  CommonTlsContext common_tls_context = 1 [(validate.rules).message = {required: true}];

  // If true, requires client certificate authentication (mTLS).
  google.protobuf.BoolValue require_client_certificate = 2;

  // Maximum TLS protocol version to negotiate.
  // If not specified, uses TLS 1.3 by default.
  TlsVersion max_protocol_version = 3;

  // Minimum TLS protocol version to accept.
  // If not specified, uses TLS 1.2 by default.
  TlsVersion min_protocol_version = 4;

  // Enable kernel TLS (kTLS) offload for improved performance.
  // When enabled, TLS encryption and decryption are performed by the Linux kernel
  // instead of in userspace, reducing CPU usage and enabling zero-copy operations.
  // Requires Linux kernel 4.13+ with kTLS support enabled.
  google.protobuf.BoolValue enable_ktls = 5;

  // Session resumption configuration for improved connection performance.
  SessionResumptionConfig session_resumption = 6;

  // If true, only enable kTLS for TX (transmit/encryption) direction.
  // RX (receive/decryption) will continue using userspace TLS.
  // This can be useful for troubleshooting or working around kernel issues.
  // Only takes effect if enable_ktls is also true. Defaults to false.
  bool ktls_tx_only = 7;
}

// Common TLS context shared between upstream and downstream configurations.
message CommonTlsContext {
  // TLS certificate configuration.
  // For upstream: client certificate for mTLS.
  // For downstream: server certificate.
  TlsCertificate tls_certificate = 1;

  // Certificate validation configuration.
  CertificateValidationContext validation_context = 2;

  // ALPN protocols to advertise during TLS handshake.
  // Common values: "h2" (HTTP/2), "http/1.1" (HTTP/1.1), "h3" (HTTP/3).
  repeated string alpn_protocols = 3;

  // Cipher suites to enable. If empty, uses rustls default secure cipher suites.
  // For TLS 1.3: TLS13_AES_128_GCM_SHA256, TLS13_AES_256_GCM_SHA384, TLS13_CHACHA20_POLY1305_SHA256
  // For TLS 1.2: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, etc.
  repeated string cipher_suites = 4;
}

// TLS certificate and private key configuration.
message TlsCertificate {
  // Certificate chain in PEM format.
  config.core.v3.DataSource certificate_chain = 1 [(validate.rules).message = {required: true}];

  // Private key in PEM format.
  config.core.v3.DataSource private_key = 2 [(validate.rules).message = {required: true}];
}

// Certificate validation context for verifying peer certificates.
message CertificateValidationContext {
  // Trusted CA certificates in PEM format for validating peer certificates.
  config.core.v3.DataSource trusted_ca = 1;

  // Optional list of Subject Alternative Names (SANs) to verify in peer certificate.
  // If specified, at least one SAN must match for validation to succeed.
  repeated string verify_subject_alt_name = 2;

  // If true, verifies that the certificate is not expired or revoked.
  google.protobuf.BoolValue verify_certificate_expiration = 3;
}

// TLS protocol version enumeration.
enum TlsVersion {
  // Allow rustls to use default version negotiation.
  TLS_AUTO = 0;
  
  // TLS 1.2
  TLSv1_2 = 1;
  
  // TLS 1.3 (recommended)
  TLSv1_3 = 2;
}

// Session resumption configuration for improved performance.
message SessionResumptionConfig {
  // Enable TLS session resumption using session tickets.
  bool enabled = 1;

  // Maximum number of session tickets to store in cache.
  // Default: 1024
  google.protobuf.UInt32Value max_session_ticket_count = 2;

  // Session ticket lifetime in seconds.
  // Default: 7200 (2 hours)
  google.protobuf.UInt32Value session_timeout_seconds = 3;
}

